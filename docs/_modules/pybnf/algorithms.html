<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pybnf.algorithms &#8212; PyBNF v0.3.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'v0.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyBNF v0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/LogoSm.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pybnf.algorithms</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Contains the Algorithm class and subclasses as well as support classes and functions for running simulations&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">distributed</span> <span class="k">import</span> <span class="n">as_completed</span>
<span class="kn">from</span> <span class="nn">distributed</span> <span class="k">import</span> <span class="n">Client</span><span class="p">,</span> <span class="n">LocalCluster</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="k">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">daskv</span>
<span class="kn">from</span> <span class="nn">distributed</span> <span class="k">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">distributedv</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">run</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">CalledProcessError</span><span class="p">,</span> <span class="n">TimeoutExpired</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">STDOUT</span>

<span class="kn">from</span> <span class="nn">.config</span> <span class="k">import</span> <span class="n">init_logging</span><span class="p">,</span> <span class="n">reinit_logging</span>
<span class="kn">from</span> <span class="nn">.data</span> <span class="k">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">.pset</span> <span class="k">import</span> <span class="n">PSet</span>
<span class="kn">from</span> <span class="nn">.pset</span> <span class="k">import</span> <span class="n">Trajectory</span>

<span class="kn">from</span> <span class="nn">.pset</span> <span class="k">import</span> <span class="n">NetModel</span><span class="p">,</span> <span class="n">BNGLModel</span><span class="p">,</span> <span class="n">SbmlModelNoTimeout</span>
<span class="kn">from</span> <span class="nn">.pset</span> <span class="k">import</span> <span class="n">OutOfBoundsException</span>
<span class="kn">from</span> <span class="nn">.pset</span> <span class="k">import</span> <span class="n">FailedSimulationError</span>
<span class="kn">from</span> <span class="nn">.printing</span> <span class="k">import</span> <span class="n">print0</span><span class="p">,</span> <span class="n">print1</span><span class="p">,</span> <span class="n">print2</span><span class="p">,</span> <span class="n">PybnfError</span>
<span class="kn">from</span> <span class="nn">.objective</span> <span class="k">import</span> <span class="n">ObjectiveCalculator</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="k">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">tornado</span> <span class="k">import</span> <span class="n">gen</span>
<span class="kn">from</span> <span class="nn">distributed.client</span> <span class="k">import</span> <span class="n">_wait</span>
<span class="kn">from</span> <span class="nn">concurrent.futures._base</span> <span class="k">import</span> <span class="n">CancelledError</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Result">[docs]</a><span class="k">class</span> <span class="nc">Result</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for the results of a single evaluation in the fitting algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Result.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Result.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paramset</span><span class="p">,</span> <span class="n">simdata</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a Result</span>

<span class="sd">        :param paramset: The parameters corresponding to this evaluation</span>
<span class="sd">        :type paramset: PSet</span>
<span class="sd">        :param simdata: The simulation results corresponding to this evaluation, as a nested dictionary structure.</span>
<span class="sd">        Top-level keys are model names and values are dictionaries whose keys are action suffixes and values are</span>
<span class="sd">        Data instances</span>
<span class="sd">        :type simdata: dict Returns a</span>
<span class="sd">        :param log: The stdout + stderr of the simulations</span>
<span class="sd">        :type log: list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pset</span> <span class="o">=</span> <span class="n">paramset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span> <span class="o">=</span> <span class="n">simdata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># To be set later when the Result is scored.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Result.normalize"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Result.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes the Data object in this result, according to settings</span>
<span class="sd">        :param settings: Config value for &#39;normalization&#39;: a string representing the normalization type, a dict mapping</span>
<span class="sd">        exp files to normalization type, or None</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">suff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suff</span><span class="p">]</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">suff</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suff</span><span class="p">]</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="n">suff</span><span class="p">])</span></div>

<div class="viewcode-block" id="Result.postprocess_data"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Result.postprocess_data">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Postprocess the Data objects in this result with a user-defined Python script</span>
<span class="sd">        :param settings: A dict that maps a tuple (model, suffix) to a Python filename to load.</span>
<span class="sd">        That file is expected to contain the definition for the function postprocess(data),</span>
<span class="sd">        which takes a Data object and returns a processed data object</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">suff</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
            <span class="n">rawdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suff</span><span class="p">]</span>
            <span class="c1"># This could generate all kinds of errors if the user&#39;s script is bad. Whatever happens, it&#39;s caught</span>
            <span class="c1"># by the caller of postprocess_data()</span>
            <span class="c1"># exec(settings[m][suff])</span>
            <span class="c1"># noinspection PyUnresolvedReferences</span>
            <span class="c1"># self.simdata[m][suff] = postprocess(rawdata)</span>

            <span class="c1"># Cleaner attempt - follows good practice and is probably faster, but makes it hard for the user to create</span>
            <span class="c1"># a new Data object if they want to do that.</span>
            <span class="c1"># However, they can do that by `dataclass = data.__class__` `newdata = dataclass()`</span>
            <span class="c1"># Import the user-specified script as a module</span>
            <span class="kn">import</span> <span class="nn">importlib.util</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="s2">&quot;postprocessor&quot;</span><span class="p">,</span> <span class="n">settings</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">suff</span><span class="p">])</span>
            <span class="n">postproc</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">postproc</span><span class="p">)</span>
            <span class="c1"># Now postproc is the user-defined Python module</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suff</span><span class="p">]</span> <span class="o">=</span> <span class="n">postproc</span><span class="o">.</span><span class="n">postprocess</span><span class="p">(</span><span class="n">rawdata</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">FailedSimulation</span><span class="p">(</span><span class="n">Result</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paramset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fail_type</span><span class="p">,</span> <span class="n">einfo</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a FailedSimulation</span>

<span class="sd">        :param paramset:</span>
<span class="sd">        :param log:</span>
<span class="sd">        :param name:</span>
<span class="sd">        :param fail_type: 0 - Exceeded walltime, 1 - Other crash</span>
<span class="sd">        :type fail_type: int</span>
<span class="sd">        :param einfo:</span>
<span class="sd">        :type einfo: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FailedSimulation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">paramset</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail_type</span> <span class="o">=</span> <span class="n">fail_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traceback</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="o">*</span><span class="n">einfo</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">postprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="k">return</span>


<div class="viewcode-block" id="run_job"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.run_job">[docs]</a><span class="k">def</span> <span class="nf">run_job</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">failed_logs_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs the Job j.</span>
<span class="sd">    This function is passed to Dask instead of j.run_simulation because if you pass j.run_simulation, Dask leaks memory</span>
<span class="sd">    associated with j.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">j</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">failed_logs_dir</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Catch the error for running out of threads here - it&#39;s the only place outside dask where we can catch it.</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;can&#39;t start new thread&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Reached thread limit - can&#39;t start new thread&quot;</span><span class="p">)</span>
            <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Too many threads! See &quot;Troubleshooting&quot; in the documentation for how to deal with this problem&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span></div>


<div class="viewcode-block" id="Job"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Job">[docs]</a><span class="k">class</span> <span class="nc">Job</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for information necessary to perform a single evaluation in the fitting algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Seeing these logs for cluster-based fitting requires configuring dask to log to the</span>
    <span class="c1"># &quot;pybnf.algorithms.job&quot; logger</span>
    <span class="n">jlogger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pybnf.algorithms.job&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Job.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Job.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">calc_future</span><span class="p">,</span> <span class="n">norm_settings</span><span class="p">,</span> <span class="n">postproc_settings</span><span class="p">,</span>
                 <span class="n">delete_folder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a Job</span>

<span class="sd">        :param models: The models to evaluate</span>
<span class="sd">        :type models: list of Model instances</span>
<span class="sd">        :param params: The parameter set with which to evaluate the model</span>
<span class="sd">        :type params: PSet</span>
<span class="sd">        :param job_id: Job identification; also the folder name that the job gets saved to</span>
<span class="sd">        :type job_id: str</span>
<span class="sd">        :param output_dir path to the directory where I should create my simulation folder</span>
<span class="sd">        :type output_dir: str</span>
<span class="sd">        :param calc_future: Future for an ObjectiveCalculator containing the objective function and experimental data,</span>
<span class="sd">        which we can use to calculate the objective value.</span>
<span class="sd">        :type calc_future: Future</span>
<span class="sd">        :param norm_settings: Config value for &#39;normalization&#39;: a string representing the normalization type, a dict</span>
<span class="sd">        mapping exp files to normalization type, or None</span>
<span class="sd">        :type norm_settings: Union[str, dict, NoneType]</span>
<span class="sd">        :param postproc_settings: dict mapping (model, suffix) tuples to the path of a Python postprocessing file to</span>
<span class="sd">        run on the result.</span>
<span class="sd">        :param delete_folder: If True, delete the folder and files created after the simulation runs</span>
<span class="sd">        :type delete_folder: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="n">models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span> <span class="o">=</span> <span class="n">job_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span> <span class="o">=</span> <span class="n">calc_future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_settings</span> <span class="o">=</span> <span class="n">norm_settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postproc_settings</span> <span class="o">=</span> <span class="n">postproc_settings</span>
        <span class="c1"># Whether to show warnings about missing data if the job includes an objective evaluation. Toggle this after</span>
        <span class="c1"># construction if needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_warnings</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>  <span class="c1"># This is safe because it is called from the scheduler, not the workers.</span>
        <span class="c1"># Force absolute paths for bngcommand and output_dir, because workers do not get the relative path info.</span>
        <span class="k">if</span> <span class="n">output_dir</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">home_dir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">output_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>

        <span class="c1"># Folder where we save the model files and outputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_folder</span> <span class="o">=</span> <span class="n">delete_folder</span></div>

    <span class="k">def</span> <span class="nf">_name_with_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="n">model_file_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_with_id</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="n">model_with_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">copy_with_param_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_with_params</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">model_file_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_copy_log_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failed_logs_dir</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">failed_logs_dir</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Cannot save log files without specified directory&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">.log&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name_with_id</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">lf</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Copying log file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">lf</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lf</span><span class="p">,</span> <span class="n">failed_logs_dir</span><span class="p">)</span>

<div class="viewcode-block" id="Job.run_simulation"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Job.run_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">failed_logs_dir</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs the simulation and reads in the result&quot;&quot;&quot;</span>

        <span class="c1"># The check here is in case dask decides to run the same job twice, both of them can complete.</span>
        <span class="n">made_folder</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">failures</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">made_folder</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Created folder </span><span class="si">%s</span><span class="s1"> for simulation&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
                <span class="n">made_folder</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Failed to create folder </span><span class="si">%s</span><span class="s1">, trying again.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
                <span class="n">failures</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folder</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">_rerun</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">failures</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Job </span><span class="si">%s</span><span class="s1"> failed because it was unable to write to the Simulations folder&#39;</span> <span class="o">%</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">simdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_models</span><span class="p">()</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">simdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">CalledProcessError</span><span class="p">,</span> <span class="n">FailedSimulationError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_log_files</span><span class="p">(</span><span class="n">failed_logs_dir</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TimeoutExpired</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_log_files</span><span class="p">(</span><span class="n">failed_logs_dir</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;File not found during job </span><span class="si">%s</span><span class="s1">. This should only happen if the fitting &#39;</span>
                                   <span class="s1">&#39;is already done.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_copy_log_files</span><span class="p">(</span><span class="n">failed_logs_dir</span><span class="p">)</span>
            <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;A simulation failed with an unknown error. See the log for details, and consider reporting this &#39;</span>
                   <span class="s1">&#39;as a bug.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Unknown error during job </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_settings</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">postprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postproc_settings</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;User-defined post-processing script failed&#39;</span><span class="p">)</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;User-defined post-processing script failed&#39;</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">evaluate_objective</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">simdata</span><span class="p">,</span> <span class="n">show_warnings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show_warnings</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Simulation corresponding to Result </span><span class="si">%s</span><span class="s1"> contained NaNs or Infs&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Discarding Result </span><span class="si">%s</span><span class="s1"> as having an infinite objective function value&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">simdata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_folder</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">run</span><span class="p">([</span><span class="s1">&#39;rm&#39;</span><span class="p">,</span> <span class="s1">&#39;-rf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">1800</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Removed folder </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">CalledProcessError</span><span class="p">,</span> <span class="n">TimeoutExpired</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jlogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Failed to remove folder </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div></div>


<div class="viewcode-block" id="JobGroup"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.JobGroup">[docs]</a><span class="k">class</span> <span class="nc">JobGroup</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a group of jobs that are identical replicates to be averaged together for smoothing</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="JobGroup.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.JobGroup.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">subjob_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param job_id: The name of the Job this group is representing</span>
<span class="sd">        :param subjob_ids: A list of the ids of the identical replicate Jobs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span> <span class="o">=</span> <span class="n">job_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subjob_ids</span> <span class="o">=</span> <span class="n">subjob_ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="JobGroup.job_finished"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.JobGroup.job_finished">[docs]</a>    <span class="k">def</span> <span class="nf">job_finished</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when one job in this group has finished</span>
<span class="sd">        :param res: Result object for the completed job</span>
<span class="sd">        :return: Boolean, whether everything in this job group has finished</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle edge cases of failed simulations - if we get one FailedSimulation, we declare the group is done,</span>
        <span class="c1"># and return a FailedSimulation object as the average</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
            <span class="c1"># JobGroup already finished when a previous failed simulation came in.</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">FailedSimulation</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subjob_ids</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Job group </span><span class="si">%s</span><span class="s1"> received unwanted result </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subjob_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="JobGroup.average_results"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.JobGroup.average_results">[docs]</a>    <span class="k">def</span> <span class="nf">average_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To be called after all results are in for this group.</span>
<span class="sd">        Averages the results and returns a new Result object containing the averages</span>

<span class="sd">        :return: New Result object with the job_id of this JobGroup and the averaged Data as the simdata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed</span>

        <span class="c1"># Iterate through the models and suffixes in the simdata strucutre, and calculate the average for each</span>
        <span class="c1"># Data object it contains</span>
        <span class="n">avedata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">simdata</span><span class="p">:</span>
            <span class="n">avedata</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span>
                <span class="n">avedata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suf</span><span class="p">]</span> <span class="o">=</span> <span class="n">Data</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">simdata</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">suf</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pset</span><span class="p">,</span> <span class="n">avedata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="custom_as_completed"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.custom_as_completed">[docs]</a><span class="k">class</span> <span class="nc">custom_as_completed</span><span class="p">(</span><span class="n">as_completed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass created to modify a section of dask.distributed code</span>
<span class="sd">    By using this subclass instead of as_completed, if you get an exception in a job,</span>
<span class="sd">    that exception is returned as the result, instead of the job disappearing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@gen</span><span class="o">.</span><span class="n">coroutine</span>
    <span class="k">def</span> <span class="nf">track_future</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">_wait</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_results</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">future</span><span class="o">.</span><span class="n">_result</span><span class="p">(</span><span class="n">raiseit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">DaskError</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">futures</span><span class="p">[</span><span class="n">future</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">futures</span><span class="p">[</span><span class="n">future</span><span class="p">]:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">futures</span><span class="p">[</span><span class="n">future</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_results</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">future</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_notify</span><span class="p">()</span></div>


<div class="viewcode-block" id="DaskError"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.DaskError">[docs]</a><span class="k">class</span> <span class="nc">DaskError</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing the result of a job that failed due to a raised exception</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traceback</span> <span class="o">=</span> <span class="n">tb</span></div>


<div class="viewcode-block" id="Algorithm"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm">[docs]</a><span class="k">class</span> <span class="nc">Algorithm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A superclass containing the structures common to all metaheuristic and MCMC-based algorithms</span>
<span class="sd">    defined in this software suite</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Algorithm.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates an Algorithm with a Configuration object.  Also initializes a</span>
<span class="sd">        Trajectory instance to track the fitting progress, and performs various additional</span>
<span class="sd">        configuration that is consistent for all algorithms</span>

<span class="sd">        :param config: The fitting configuration</span>
<span class="sd">        :type config: Configuration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">exp_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">obj</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Instantiating Trajectory object&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;num_to_output&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_id_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_group_dir</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Creating output directory&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Simulations&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Results&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/FailedSimLogs&#39;</span>

        <span class="c1"># Generate a list of variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">variables</span>

        <span class="c1"># Store a list of all Model objects. Change this as needed for compatibility with other parts</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing models&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_models</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_fit_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Created during Algorithm.run()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refine</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Algorithm.reset"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the Algorithm, keeping loaded variables and models</span>

<span class="sd">        :param bootstrap: The bootstrap number (None if not bootstrapping)</span>
<span class="sd">        :type bootstrap: int or None</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resetting Algorithm for another run&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;num_to_output&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_id_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_group_dir</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">bootstrap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="o">=</span> <span class="n">bootstrap</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Simulations-boot</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bootstrap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Results-boot</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bootstrap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/FailedSimLogs-boot</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bootstrap</span>
            <span class="k">for</span> <span class="n">boot_dir</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">boot_dir</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">boot_dir</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">boot_dir</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_fit_obj</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Algorithm.should_pickle"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.should_pickle">[docs]</a>    <span class="k">def</span> <span class="nf">should_pickle</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks to see if key &#39;k&#39; should be included in pickling.  Currently allows all entries in instance dictionary</span>
<span class="sd">        except for &#39;trajectory&#39;</span>

<span class="sd">        :param k:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;trajectory&#39;</span><span class="p">,</span> <span class="s1">&#39;calc_future&#39;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_pickle</span><span class="p">(</span><span class="n">k</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">backup_params</span> <span class="o">=</span> <span class="s1">&#39;sorted_params_backup.txt&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine</span> <span class="k">else</span> <span class="s1">&#39;sorted_params_refine_backup.txt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">load_trajectory</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">,</span> <span class="n">backup_params</span><span class="p">),</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;num_to_output&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to load trajectory from file&#39;</span><span class="p">)</span>
            <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Failed to load Results/sorted_params_backup.txt . Still resuming your run, but when I save the &#39;</span>
                   <span class="s1">&#39;best fits, it will only be the ones I</span><span class="se">\&#39;</span><span class="s1">ve seen since resuming.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;num_to_output&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_initialize_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks initial BNGLModel instances from the Configuration object for models that</span>
<span class="sd">        can be reinstantiated as NetModel instances</span>

<span class="sd">        :return: list of Model instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Todo: Move to config or BNGL model class?</span>
        <span class="n">home_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">])</span>  <span class="c1"># requires creation of this directory prior to function call</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Copying list of models&#39;</span><span class="p">)</span>
        <span class="n">init_model_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>  <span class="c1"># keeps Configuration object unchanged</span>
        <span class="n">final_model_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">init_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;/Initialize&#39;</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">init_model_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">BNGLModel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">generates_network</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Model </span><span class="si">%s</span><span class="s1"> requires network generation&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">init_dir</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Creating initialization directory: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">init_dir</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">init_dir</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">init_dir</span><span class="p">)</span>

                <span class="n">gnm_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_gen_net&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span>
                <span class="n">default_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">([</span><span class="n">var</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">default_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
                <span class="n">m</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">gnm_name</span><span class="p">,</span> <span class="n">gen_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pset</span><span class="o">=</span><span class="n">default_pset</span><span class="p">)</span>
                <span class="n">gn_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bng_command&#39;</span><span class="p">],</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.bngl&#39;</span> <span class="o">%</span> <span class="n">gnm_name</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.log&#39;</span> <span class="o">%</span> <span class="n">gnm_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">lf</span><span class="p">:</span>
                        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Generating network for model </span><span class="si">%s</span><span class="s1">.bngl&#39;</span> <span class="o">%</span> <span class="n">gnm_name</span><span class="p">)</span>
                        <span class="n">run</span><span class="p">(</span><span class="n">gn_cmd</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">STDOUT</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">lf</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;wall_time_gen&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Command </span><span class="si">%s</span><span class="s2"> failed in directory </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gn_cmd</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Error: Initial network generation failed for model </span><span class="si">%s</span><span class="s1">... see BioNetGen error log at &#39;</span>
                           <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">.log&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">gnm_name</span><span class="p">))</span>
                    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">TimeoutExpired</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Network generation exceeded </span><span class="si">%d</span><span class="s2"> seconds... exiting&quot;</span> <span class="o">%</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;wall_time_gen&#39;</span><span class="p">])</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Network generation took too long.  Increase &#39;wall_time_gen&#39; configuration parameter&quot;</span><span class="p">)</span>
                    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">tb</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_list</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Other exception occurred:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tb</span><span class="p">)</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;Unknown error occurred during network generation, see log... exiting&quot;</span><span class="p">)</span>
                    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">home_dir</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Output for network generation of model </span><span class="si">%s</span><span class="s1"> logged in </span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">.log&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">init_dir</span><span class="p">,</span> <span class="n">gnm_name</span><span class="p">))</span>
                <span class="n">final_model_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NetModel</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">actions</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">suffixes</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">mutants</span><span class="p">,</span> <span class="n">nf</span><span class="o">=</span><span class="n">init_dir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">gnm_name</span> <span class="o">+</span> <span class="s1">&#39;.net&#39;</span><span class="p">))</span>
                <span class="n">final_model_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bng_command</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">bng_command</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Model </span><span class="si">%s</span><span class="s1"> does not require network generation&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">final_model_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">home_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_model_list</span>

<div class="viewcode-block" id="Algorithm.start_run"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.start_run">[docs]</a>    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the scheduler at the start of a fitting run.</span>
<span class="sd">        Must return a list of PSets that the scheduler should run.</span>

<span class="sd">        Algorithm subclasses optionally may set the .name field of the PSet objects to give a meaningful unique</span>
<span class="sd">        identifier such as &#39;gen0ind42&#39;. If so, they MUST BE UNIQUE, as this determines the folder name.</span>
<span class="sd">        Uniqueness will not be checked elsewhere.</span>

<span class="sd">        :return: list of PSets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement start_run()&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the scheduler when a simulation is completed, with the pset that was run, and the resulting simulation</span>
<span class="sd">        data</span>

<span class="sd">        :param res: result from the completed simulation</span>
<span class="sd">        :type res: Result</span>
<span class="sd">        :return: List of PSet(s) to be run next or &#39;STOP&#39; string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses must implement got_result()&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.add_to_trajectory"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.add_to_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the information from a Result to the Trajectory instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate objective if it wasn&#39;t done on workers.</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Check if the objective wasn&#39;t evaluated on the workers</span>
            <span class="n">res</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;normalization&#39;</span><span class="p">])</span>
            <span class="c1"># Do custom postprocessing, if any</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">postprocess_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">postprocessing</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;User-defined post-processing script failed&#39;</span><span class="p">)</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;User-defined post-processing script failed&#39;</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">evaluate_multiple</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">simdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Check if the above evaluation failed</span>
                <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Simulation corresponding to Result </span><span class="si">%s</span><span class="s1"> contained NaNs or Infs&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Discarding Result </span><span class="si">%s</span><span class="s1"> as having an infinite objective function value&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Simulation data in Result </span><span class="si">%s</span><span class="s1"> has NaN or Inf values.  Discarding this parameter set&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Adding Result </span><span class="si">%s</span><span class="s1"> to Trajectory with score </span><span class="si">%.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">pset</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.random_pset"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.random_pset">[docs]</a>    <span class="k">def</span> <span class="nf">random_pset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random PSet based on the distributions and bounds for each parameter specified in the configuration</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Generating a randomly distributed PSet&quot;</span><span class="p">)</span>
        <span class="n">pset_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">sample_value</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">PSet</span><span class="p">(</span><span class="n">pset_vars</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.random_latin_hypercube_psets"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.random_latin_hypercube_psets">[docs]</a>    <span class="k">def</span> <span class="nf">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates n random PSets with a latin hypercube distribution</span>
<span class="sd">        More specifically, the uniform_var and loguniform_var variables follow the latin hypercube distribution,</span>
<span class="sd">        while lognorm are randomized normally.</span>

<span class="sd">        :param n: Number of psets to generate</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Generating PSets using Latin hypercube sampling&quot;</span><span class="p">)</span>
        <span class="n">num_uniform_vars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;uniform_var&#39;</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;loguniform_var&#39;</span><span class="p">:</span>
                <span class="n">num_uniform_vars</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Generate latin hypercube of dimension = number of uniformly distributed variables.</span>
        <span class="n">rands</span> <span class="o">=</span> <span class="n">latin_hypercube</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">num_uniform_vars</span><span class="p">)</span>
        <span class="n">psets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rands</span><span class="p">:</span>
            <span class="c1"># Initialize the variables</span>
            <span class="c1"># Convert the 0 to 1 random numbers to the required variable range</span>
            <span class="n">pset_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">rowindex</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;uniform_var&#39;</span><span class="p">:</span>
                    <span class="n">rescaled_val</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">rowindex</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="o">-</span><span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">rescaled_val</span><span class="p">))</span>
                    <span class="n">rowindex</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;loguniform_var&#39;</span><span class="p">:</span>
                    <span class="n">rescaled_val</span> <span class="o">=</span> <span class="n">exp10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">rowindex</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">)))</span>
                    <span class="n">pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">rescaled_val</span><span class="p">))</span>
                    <span class="n">rowindex</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">sample_value</span><span class="p">())</span>
            <span class="n">psets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PSet</span><span class="p">(</span><span class="n">pset_vars</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">psets</span></div>

<div class="viewcode-block" id="Algorithm.make_job"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.make_job">[docs]</a>    <span class="k">def</span> <span class="nf">make_job</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new Job using the specified params, and additional specifications that are already saved in the</span>
<span class="sd">        Algorithm object</span>
<span class="sd">        If smoothing is turned on, makes n identical Jobs and a JobGroup</span>

<span class="sd">        :param params:</span>
<span class="sd">        :type params: PSet</span>
<span class="sd">        :return: list of Jobs (of length equal to smoothing setting)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">job_id</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">job_id_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">job_id</span> <span class="o">=</span> <span class="s1">&#39;sim_</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_id_counter</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Creating Job </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Create a single job</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Job</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;wall_time_sim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;normalization&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">postprocessing</span><span class="p">,</span>
                    <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">]))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create multiple identical Jobs for use with smoothing</span>
            <span class="n">newjobs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">newnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]):</span>
                <span class="n">thisname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_rep</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">newnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisname</span><span class="p">)</span>
                <span class="c1"># calc_future is supposed to be None here - the workers don&#39;t have enough info to calculate the</span>
                <span class="c1"># objective on their own</span>
                <span class="n">newjobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Job</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">thisname</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;wall_time_sim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;normalization&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">(),</span>
                                   <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">])))</span>
            <span class="n">new_group</span> <span class="o">=</span> <span class="n">JobGroup</span><span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="n">newnames</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">newnames</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">job_group_dir</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
            <span class="k">return</span> <span class="n">newjobs</span></div>

<div class="viewcode-block" id="Algorithm.output_results"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.output_results">[docs]</a>    <span class="k">def</span> <span class="nf">output_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">no_move</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells the Trajectory to output a log file now with the current best fits.</span>

<span class="sd">        This should be called periodically by each Algorithm subclass, and is called by the Algorithm class at the end</span>
<span class="sd">        of the simulation.</span>
<span class="sd">        :return:</span>
<span class="sd">        :param name: Custom string to add to the saved filename. If omitted, we just use a running counter of the</span>
<span class="sd">        number of times we&#39;ve outputted.</span>
<span class="sd">        :param no_move: If True, overrides the config setting delete_old_files=2, and does not move the result to</span>
<span class="sd">        overwrite sorted_params.txt</span>
<span class="sd">        :type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_counter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;refine_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/sorted_params_</span><span class="si">%s</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Outputting results to file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">write_to_file</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># If the user has asked for fewer output files, each time we&#39;re here, move the new file to</span>
        <span class="c1"># Results/sorted_params.txt, overwriting the previous one.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">no_move</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Overwriting previous &#39;sorted_params.txt&#39;&quot;</span><span class="p">)</span>
            <span class="n">noname_filepath</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/sorted_params.txt&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">noname_filepath</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">noname_filepath</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">noname_filepath</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.backup"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.backup">[docs]</a>    <span class="k">def</span> <span class="nf">backup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pending_psets</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a backup of this algorithm object that can be reloaded later to resume the run</span>

<span class="sd">        :param pending_psets: Iterable of PSets that are currently submitted as jobs, and will need to get re-submitted</span>
<span class="sd">        when resuming the algorithm</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Saving a backup of the algorithm&#39;</span><span class="p">)</span>
        <span class="c1"># Save a backup of the PSets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;backup&#39;</span><span class="p">,</span> <span class="n">no_move</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Pickle the algorithm</span>
        <span class="n">picklepath</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/alg_backup.bp&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">picklepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">pending_psets</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to save backup of algorithm&#39;</span><span class="p">)</span>
            <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Failed to save backup of the algorithm.</span><span class="se">\n</span><span class="s1">See log for more information&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span> <span class="o">==</span> <span class="s1">&#39;Too many open files&#39;</span><span class="p">:</span>
                <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Too many open files! See &quot;Troubleshooting&quot; in the documentation for how to deal with this &#39;</span>
                       <span class="s1">&#39;problem.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Algorithm.get_backup_every"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.get_backup_every">[docs]</a>    <span class="k">def</span> <span class="nf">get_backup_every</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a number telling after how many individual simulation returns should we back up the algorithm.</span>
<span class="sd">        Makes a good guess, but could be overridden in a subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;backup_every&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">*</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Algorithm.add_iterations"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.add_iterations">[docs]</a>    <span class="k">def</span> <span class="nf">add_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds n additional iterations to the algorithm.</span>
<span class="sd">        May be overridden in subclasses that don&#39;t use self.max_iterations to track the iteration count</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">+=</span> <span class="n">n</span></div>

<div class="viewcode-block" id="Algorithm.run"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_prefix</span><span class="p">,</span> <span class="n">scheduler_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reuse_client</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Main loop for executing the algorithm&quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Initializing dask Client with dask v</span><span class="si">%s</span><span class="s1">, distributed v</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">daskv</span><span class="p">,</span> <span class="n">distributedv</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Setting up Simplex refinement of previous algorithm&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reuse_client</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reusing Client from the previous run&#39;</span><span class="p">)</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">reuse_client</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;scheduler_file&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Scheduler node read in from scheduler file stored on shared file system</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">scheduler_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;scheduler_file&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">scheduler_node</span><span class="p">:</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">:8786&#39;</span> <span class="o">%</span> <span class="n">scheduler_node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;parallel_count&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">LocalCluster</span><span class="p">(</span><span class="n">n_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;parallel_count&#39;</span><span class="p">],</span> <span class="n">threads_per_worker</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
            <span class="n">client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">init_logging</span><span class="p">,</span> <span class="n">log_prefix</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
            <span class="n">client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">init_logging</span><span class="p">,</span> <span class="n">log_prefix</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>

        <span class="c1"># Required because with distributed v1.22.0, logger breaks after calling Client()</span>
        <span class="n">reinit_logging</span><span class="p">(</span><span class="n">log_prefix</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>

        <span class="n">backup_every</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_backup_every</span><span class="p">()</span>
        <span class="n">sim_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Generating initial parameter sets&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="n">resume</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Resume algorithm with the following PSets: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">resume</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_run</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;local_objective_eval&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">calculator</span> <span class="o">=</span> <span class="n">ObjectiveCalculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span><span class="p">]</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">calculator</span><span class="p">],</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_future</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Maps pending futures to tuple (PSet, job_id).</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">psets</span><span class="p">:</span>
            <span class="n">jobs</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_job</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">jobs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">show_warnings</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># For only the first job submitted, show warnings if exp data is unused.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Submitting initial set of </span><span class="si">%d</span><span class="s1"> Jobs&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">run_job</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span><span class="p">)</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">pending</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">custom_as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">with_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">raise_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sim_count</span> <span class="o">%</span> <span class="n">backup_every</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sim_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backup</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">pending</span><span class="p">[</span><span class="n">fut</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fut</span> <span class="ow">in</span> <span class="n">pending</span><span class="p">]))</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">DaskError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">PybnfError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">res</span><span class="o">.</span><span class="n">error</span>  <span class="c1"># User-targeted error should be raised instead of skipped</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Job failed with an exception&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">traceback</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">FailedSimulation</span><span class="p">(</span><span class="n">pending</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pending</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="c1"># Handle if this result is one of multiple instances for smoothing</span>
            <span class="n">sim_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="n">pending</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_group_dir</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">done</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">job_finished</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">average_results</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">FailedSimulation</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">fail_type</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fail_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">tb</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">res</span><span class="o">.</span><span class="n">traceback</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">fail_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Job </span><span class="si">%s</span><span class="s1"> failed with code </span><span class="si">%d%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">fail_type</span><span class="p">,</span> <span class="n">tb</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">fail_type</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Job </span><span class="si">%s</span><span class="s1"> failed&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Job </span><span class="si">%s</span><span class="s1"> timed out&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">success_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fail_count</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PybnfError</span><span class="p">(</span><span class="s1">&#39;Aborted because all jobs are failing&#39;</span><span class="p">,</span>
                                     <span class="s1">&#39;Your simulations are failing to run. See the log files in &#39;</span>
                                     <span class="s1">&#39;the </span><span class="si">%s</span><span class="s1"> directory.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;FailedSimLogs&#39;</span> <span class="k">if</span> <span class="n">debug</span> <span class="k">else</span> <span class="s1">&#39;Simulations&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">success_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Job </span><span class="si">%s</span><span class="s1"> complete&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_trajectory</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;min_objective&#39;</span><span class="p">]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Minimum objective value achieved&#39;</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Minimum objective value achieved&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">got_result</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;STOP&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_fit_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">best_score</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stop criterion satisfied with objective function value of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_fit_obj</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s2">&quot;Stop criterion satisfied with objective function value of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_fit_obj</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_futures</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">response</span><span class="p">:</span>
                    <span class="n">new_js</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_job</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">new_j</span> <span class="ow">in</span> <span class="n">new_js</span><span class="p">:</span>
                        <span class="n">new_f</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">run_job</span><span class="p">,</span> <span class="n">new_j</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_logs_dir</span><span class="p">)</span>
                        <span class="n">pending</span><span class="p">[</span><span class="n">new_f</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">new_j</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
                        <span class="n">new_futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_f</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Submitting </span><span class="si">%d</span><span class="s1"> new Jobs&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_futures</span><span class="p">))</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_futures</span><span class="p">)</span>
        <span class="c1"># If we&#39;ll be calling more run()&#39;s, save the client to avoid reinitializing</span>
        <span class="n">save_client</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">])</span> \
                      <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;refine&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimplexAlgorithm</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cancelling </span><span class="si">%d</span><span class="s2"> pending jobs&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">pending</span><span class="p">))</span>
        <span class="n">client</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pending</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">save_client</span><span class="p">:</span>
            <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">(</span><span class="s1">&#39;final&#39;</span><span class="p">)</span>

        <span class="c1"># Copy the best simulations into the results folder</span>
        <span class="n">best_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">best_fit_name</span><span class="p">()</span>
        <span class="n">best_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">best_fit</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Copying simulation results from best fit parameter set to Results/ folder&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="n">this_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">models</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">to_save</span> <span class="o">=</span> <span class="n">this_model</span><span class="o">.</span><span class="n">copy_with_param_set</span><span class="p">(</span><span class="n">best_pset</span><span class="p">)</span>
            <span class="n">to_save</span><span class="o">.</span><span class="n">save_all</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">,</span> <span class="n">to_save</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">best_name</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">simtype</span><span class="p">,</span> <span class="n">suf</span> <span class="ow">in</span> <span class="n">this_model</span><span class="o">.</span><span class="n">suffixes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">simtype</span> <span class="o">==</span> <span class="s1">&#39;simulate&#39;</span><span class="p">:</span>
                        <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;gdat&#39;</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># parameter_scan</span>
                        <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;scan&#39;</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">best_name</span> <span class="o">=</span> <span class="n">best_name</span> <span class="o">+</span> <span class="s1">&#39;_rep0&#39;</span>  <span class="c1"># Look for one specific replicate of the data</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">/</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">,</span> <span class="n">best_name</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">best_name</span><span class="p">,</span> <span class="n">suf</span><span class="p">,</span> <span class="n">ext</span><span class="p">),</span>
                                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Cannot find files corresponding to best fit parameter set&#39;</span><span class="p">)</span>
                        <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Could not find your best fit gdat file. This could happen if all of the simulations</span><span class="se">\n</span><span class="s1">&#39;</span>
                               <span class="s1">&#39; in your run failed, or if that gdat file was somehow deleted during the run.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;save_best_data&#39;</span><span class="p">]:</span>
            <span class="c1"># Rerun the best fit parameter set so the gdat file(s) are saved in the Results folder.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Rerunning best fit parameter set to save data files.&#39;</span><span class="p">)</span>
            <span class="c1"># Enable saving files for SBML models</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">SbmlModelNoTimeout</span><span class="p">):</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">save_files</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">finaljob</span> <span class="o">=</span> <span class="n">Job</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">,</span> <span class="n">best_pset</span><span class="p">,</span> <span class="s1">&#39;bestfit&#39;</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;wall_time_sim&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;normalization&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">postprocessing</span><span class="p">,</span>
                           <span class="kc">False</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">run_job</span><span class="p">(</span><span class="n">finaljob</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Failed to rerun best fit parameter set&#39;</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Failed to rerun best fit parameter set. See log for details&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Copy all gdat and scan to Results</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="o">+</span><span class="s1">&#39;/bestfit/*.gdat&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">glob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="o">+</span><span class="s1">&#39;/bestfit/*.scan&#39;</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_dir</span><span class="p">)</span>
            <span class="c1"># Disable saving files for SBML models (in case there is future bootstrapping or refinement)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">SbmlModelNoTimeout</span><span class="p">):</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">save_files</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bootstrap&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/alg_backup.bp&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">],</span>
                          <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/alg_</span><span class="si">%s</span><span class="s1">.bp&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">],</span>
                                            <span class="p">(</span><span class="s1">&#39;finished&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine</span> <span class="k">else</span> <span class="s1">&#39;refine_finished&#39;</span><span class="p">)))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Renamed pickled algorithm backup to alg_</span><span class="si">%s</span><span class="s1">.bp&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="s1">&#39;finished&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine</span> <span class="k">else</span> <span class="s1">&#39;refine_finished&#39;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Tried to move pickled algorithm, but it was not found&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimplexAlgorithm</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;refine&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># End of fitting; delete unneeded files</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;delete_old_files&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">run</span><span class="p">([</span><span class="s1">&#39;rm&#39;</span><span class="p">,</span> <span class="s1">&#39;-rf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_dir</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fitting complete&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_client</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">client</span></div>

<div class="viewcode-block" id="Algorithm.cleanup"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.Algorithm.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called before the program exits due to an exception.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ParticleSwarm"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ParticleSwarm">[docs]</a><span class="k">class</span> <span class="nc">ParticleSwarm</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements particle swarm optimization.</span>

<span class="sd">    The implementation roughly follows Moraes et al 2015, although is reorganized to better suit PyBNF&#39;s format.</span>
<span class="sd">    Note the global convergence criterion discussed in that paper is not used (would require too long a</span>
<span class="sd">    computation), and instead uses ????</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ParticleSwarm.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ParticleSwarm.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>

        <span class="c1"># Former params that are now part of the config</span>
        <span class="c1"># variable_list, num_particles, max_evals, cognitive=1.5, social=1.5, w0=1.,</span>
        <span class="c1"># wf=0.1, nmax=30, n_stop=np.inf, absolute_tol=0., relative_tol=0.)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial configuration of particle swarm optimizer</span>
<span class="sd">        :param conf_dict: The fitting configuration</span>
<span class="sd">        :type conf_dict: Configuration</span>

<span class="sd">        The config should contain the following definitions:</span>

<span class="sd">        population_size - Number of particles in the swarm</span>
<span class="sd">        max_iterations - Maximum number of iterations. More precisely, the max number of simulations run is this times</span>
<span class="sd">        the population size.</span>
<span class="sd">        cognitive - Acceleration toward the particle&#39;s own best</span>
<span class="sd">        social - Acceleration toward the global best</span>
<span class="sd">        particle_weight - Inertia weight of the particle (default 1)</span>

<span class="sd">        The following config parameters relate to the complicated method presented is Moraes et al for adjusting the</span>
<span class="sd">        inertia weight as you go. These are optional, and this feature will be disabled (by setting</span>
<span class="sd">        particle_weight_final = particle_weight) if these are not included.</span>
<span class="sd">        It remains to be seen whether this method is at all useful for our applications.</span>

<span class="sd">        particle_weight_final -  Inertia weight at the end of the simulation</span>
<span class="sd">        adaptive_n_max - Controls how quickly we approach wf - After nmax &quot;unproductive&quot; iterations, we are halfway from</span>
<span class="sd">        w0 to wf</span>
<span class="sd">        adaptive_n_stop - nd the entire run if we have had this many &quot;unproductive&quot; iterations (should be more than</span>
<span class="sd">        adaptive_n_max)</span>
<span class="sd">        adaptive_abs_tol - Tolerance for determining if an iteration was &quot;unproductive&quot;. A run is unproductive if the</span>
<span class="sd">        change in global_best is less than absolute_tol + relative_tol * global_best</span>
<span class="sd">        adaptive_rel_tol - Tolerance 2 for determining if an iteration was &quot;unproductive&quot; (see above)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ParticleSwarm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># This default value gets special treatment because if missing, it should take the value of particle_weight,</span>
        <span class="c1"># disabling the adaptive weight change entirely.</span>
        <span class="k">if</span> <span class="s1">&#39;particle_weight_final&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;particle_weight_final&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;particle_weight&#39;</span><span class="p">]</span>

        <span class="c1"># Save config parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cognitive&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;social&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_every</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span>
        <span class="c1"># Todo: Nice error message if a required key is missing</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">w0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;particle_weight&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;particle_weight_final&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;adaptive_n_max&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;adaptive_n_stop&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">absolute_tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;adaptive_abs_tol&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;adaptive_rel_tol&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Counter that controls the current weight. Counts number of &quot;unproductive&quot; iterations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Counter for the total number of results received</span>

        <span class="c1"># Initialize storage for the swarm data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of lists of the form [PSet, velocity]. Velocity is stored as a dict with the same keys</span>
        <span class="c1"># as PSet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Maps each PSet to it s particle number, for easy lookup.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bests</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span>  <span class="c1"># The best result for each particle: list of the</span>
        <span class="c1"># form [PSet, objective]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>  <span class="c1"># The best result for the whole swarm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParticleSwarm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bests</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

<div class="viewcode-block" id="ParticleSwarm.start_run"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ParticleSwarm.start_run">[docs]</a>    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the run by initializing n particles at random positions and velocities</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running Particle Swarm Optimization with </span><span class="si">%i</span><span class="s1"> particles for </span><span class="si">%i</span><span class="s1"> total simulations&#39;</span> <span class="o">%</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;initialization&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lh&#39;</span><span class="p">:</span>
            <span class="n">new_params_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_params_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_params_list</span><span class="p">)):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">new_params_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter0p</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

            <span class="c1"># As suggested by Engelbrecht 2012, set all initial velocities to 0</span>
            <span class="n">new_velocity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="mf">0.</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">})</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">new_velocity</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># Index of the newly added PSet.</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">particle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParticleSwarm.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ParticleSwarm.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates particle velocity and position after a simulation completes.</span>

<span class="sd">        :param res: Result object containing the run PSet and the resulting Data.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">paramset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_particles</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> simulations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> simulations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span><span class="p">))</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current best score: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># End of one &quot;pseudoflight&quot;, check if it was productive.</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_best</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_best</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">absolute_tol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_tol</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_best</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check stop criterion</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;v_stop&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_speed</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
                <span class="k">if</span> <span class="n">max_speed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;v_stop&#39;</span><span class="p">]:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Stopping particle swarm because the max speed is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">max_speed</span><span class="p">)</span>
                    <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">paramset</span><span class="p">)</span>  <span class="c1"># Particle number</span>

        <span class="c1"># Update best scores if needed.</span>
        <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bests</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bests</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">paramset</span><span class="p">,</span> <span class="n">score</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span> <span class="o">=</span> <span class="p">[</span><span class="n">paramset</span><span class="p">,</span> <span class="n">score</span><span class="p">]</span>

        <span class="c1"># Update own position and velocity</span>
        <span class="c1"># The order matters - updating velocity first seems to make the best use of our current info.</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w0</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">w0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bests</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="o">+</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_best</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">}</span>

        <span class="c1"># Manually check to determine if reflection occurred (i.e. attempted assigning of variable outside its bounds)</span>
        <span class="c1"># If so, update based on reflection protocol and set velocity to 0</span>
        <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="mf">10.</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_val</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_val</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">.</span><span class="n">lower_bound</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">upper_bound</span> <span class="o">&lt;</span> <span class="n">new_val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pset</span>

        <span class="c1"># This will cause a crash if new_pset happens to be the same as an already running pset in pset_map.</span>
        <span class="c1"># This could come up in practice if all parameters have hit a box constraint.</span>
        <span class="c1"># As a simple workaround, perturb the parameters slightly</span>
        <span class="k">while</span> <span class="n">new_pset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span><span class="p">:</span>
            <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">add_rand</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swarm</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pset_map</span><span class="p">[</span><span class="n">new_pset</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

        <span class="c1"># Set the new name: the old pset name is iter##p##</span>
        <span class="c1"># Extract the iter number</span>
        <span class="n">iternum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;iter([0-9]+)&#39;</span><span class="p">,</span> <span class="n">paramset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">p</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iternum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># Check for stopping criteria</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_evals</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nv</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">new_pset</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">add_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span></div>


<span class="k">class</span> <span class="nc">DifferentialEvolutionBase</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DifferentialEvolutionBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;mutation_rate&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutation_factor</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;mutation_factor&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop_tolerance</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;stop_tolerance&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;de_strategy&#39;</span><span class="p">]</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;rand1&#39;</span><span class="p">,</span> <span class="s1">&#39;rand2&#39;</span><span class="p">,</span> <span class="s1">&#39;best1&#39;</span><span class="p">,</span> <span class="s1">&#39;best2&#39;</span><span class="p">,</span> <span class="s1">&#39;all1&#39;</span><span class="p">,</span> <span class="s1">&#39;all2&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PybnfError</span><span class="p">(</span><span class="s1">&#39;Invalid differential evolution strategy &quot;</span><span class="si">%s</span><span class="s1">&quot;. Options are: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">options</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">individuals</span><span class="p">,</span> <span class="n">base_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new individual for the specified island, according to the set strategy</span>

<span class="sd">        :param base_index: The index to use for the new individual, or None for a random index.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Choose a starting parameter set (either a random one or the base_index specified)</span>
        <span class="c1"># and others to cross over (always random)</span>

        <span class="k">if</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
            <span class="n">pickn</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pickn</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="c1"># Choose pickn random unique indices, or if base_index was given, choose base_index followed by pickn-1 unique</span>
        <span class="c1"># indices</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">),</span> <span class="n">pickn</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">base_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base_index</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">:</span>
                <span class="c1"># If we accidentally picked base_index, replace it with picks[0], preserving uniqueness in our list</span>
                <span class="n">iswitch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">base_index</span><span class="p">)</span>
                <span class="n">picks</span><span class="p">[</span><span class="n">iswitch</span><span class="p">]</span> <span class="o">=</span> <span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now overwrite picks[0] with base_index. If we have base_index, picks[0] was an &quot;extra pick&quot; we only needed</span>
            <span class="c1"># in case we sampled base_index and had to replace it.</span>
            <span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_index</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">individuals</span><span class="p">[</span><span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="n">individuals</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

        <span class="c1"># Iterate through parameters; decide whether to mutate or leave the same.</span>
        <span class="n">new_pset_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">base</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_rate</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
                    <span class="n">update_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_factor</span> <span class="o">*</span> <span class="n">others</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">others</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">update_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutation_factor</span> <span class="o">*</span> <span class="n">others</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">others</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="o">+</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">mutation_factor</span> <span class="o">*</span> <span class="n">others</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">others</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">new_pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">update_val</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pset_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_pset_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;start_run() not implemented in DifferentialEvolutionBase class&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;got_result() not implemented in DifferentialEvolutionBase class&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="DifferentialEvolution"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.DifferentialEvolution">[docs]</a><span class="k">class</span> <span class="nc">DifferentialEvolution</span><span class="p">(</span><span class="n">DifferentialEvolutionBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the parallelized, island-based differential evolution algorithm</span>
<span class="sd">    described in Penas et al 2015.</span>

<span class="sd">    In some cases, I had to make my own decisions for specifics I couldn&#39;t find in the original paper. Namely:</span>
<span class="sd">    At each migration, a user-defined number of individuals are migrated from each island. For each individual, a</span>
<span class="sd">    random index is chosen; the same index for all islands. A random permutation is used to redistribute individuals</span>
<span class="sd">    with that index to different islands.</span>

<span class="sd">    Each island performs its migration individually, on the first callback when all islands are ready for that</span>
<span class="sd">    migration.It receives individuals from the migration iteration, regardless of what the current iteration is.</span>
<span class="sd">    This can sometimes lead to wasted effort.</span>
<span class="sd">    For example, suppose migration is set to occur at iteration 40, but island 1 has reached iteration 42 by the time</span>
<span class="sd">    all islands reach 40. Individual j on island 1 after iteration 42 gets replaced with individual j on island X</span>
<span class="sd">    after iteration 40. Some other island Y receives individual j on island 1 after iteration 40.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DifferentialEvolution.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.DifferentialEvolution.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes algorithm based on the config object.</span>

<span class="sd">        The following config keys specify algorithm parameters. For move information, see config_documentation.txt</span>
<span class="sd">        population_size</span>
<span class="sd">        num_islands</span>
<span class="sd">        max_iterations</span>
<span class="sd">        mutation_rate</span>
<span class="sd">        mutation_factor</span>
<span class="sd">        migrate_every</span>
<span class="sd">        num_to_migrate</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DifferentialEvolution</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;islands&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;islands&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Reduced population_size to </span><span class="si">%i</span><span class="s1"> to evenly distribute it over </span><span class="si">%i</span><span class="s1"> islands&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrate_every</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;migrate_every&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">migrate_every</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_to_migrate</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;num_to_migrate&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Maps each proposed PSet to its location (island, individual_i)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>  <span class="c1"># Count the number of completed iterations on each island</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Count of the number of PSets that are pending evaluation on the current iteration of each island.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Nested list; individuals[i][j] gives individual j on island i.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Nested list of the same shape, gives individuals proposed for replacement in next generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Nested list of same shape, gives fitness of each individual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_ready</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>  <span class="c1"># What migration number is each island ready for</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>  <span class="c1"># What migration number has each island completed</span>

        <span class="c1"># These variables store data related to individual migrations.</span>
        <span class="c1"># Each one has migration number as keys. When the first island starts migration, the required entries are</span>
        <span class="c1"># created. When the last island completes migration, they are deleted to keep these structures small.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Store (PSet, fitness) tuples here that are getting migrated - one list per island</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Which individual numbers are migrating in migration i - a single tuple for</span>
        <span class="c1"># each migration, used for all islands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_perms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># How do we rearrange between islands on migration i?</span></div>
        <span class="c1"># For each migration, a list of num_to_migrate permutations of range(num_islands)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DifferentialEvolution</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_ready</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migration_perms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running Differential Evolution with population size </span><span class="si">%i</span><span class="s1"> for up to </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running island-based Differential Evolution with </span><span class="si">%i</span><span class="s1"> islands of </span><span class="si">%i</span><span class="s1"> individuals each, &#39;</span>
                   <span class="s1">&#39;for up to </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>

        <span class="c1"># Initialize random individuals</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;initialization&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lh&#39;</span><span class="p">:</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">psets</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">]</span>
                                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">)]</span>
                                         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)]</span>

        <span class="c1"># Initialize the individual list to empty, will be filled with the proposed_individuals once their fitnesses</span>
        <span class="c1"># are computed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">)]</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)]</span>

        <span class="c1"># Set all fitnesses to Inf, guaranteeing a replacement by the first proposed individual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">)]</span>
                          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen0ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">j</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen0isl</span><span class="si">%i</span><span class="s1">ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">island</span><span class="p">]</span>

<div class="viewcode-block" id="DifferentialEvolution.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.DifferentialEvolution.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when a simulation run finishes</span>

<span class="sd">        This is not thread safe - the Scheduler must ensure only one process at a time enters</span>
<span class="sd">        this function.</span>
<span class="sd">        (or, I should rewrite this function to make it thread safe)</span>

<span class="sd">        :param res: Result object</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="c1"># Calculate the fitness of this individual, and replace if it is better than the previous one.</span>
        <span class="n">island</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pset</span><span class="p">)</span>
        <span class="n">fitness</span> <span class="o">=</span> <span class="n">score</span>
        <span class="k">if</span> <span class="n">fitness</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitness</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Determine if the current iteration is over for the current island</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]:</span>
                <span class="c1"># Last island to complete this iteration</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current population fitnesses:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">:</span>
                    <span class="n">print2</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="c1"># Submit no more jobs for this island</span>
                <span class="c1"># Once all islands reach this, simulation is over.</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrate_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This island prepares for migration</span>
                <span class="n">migration_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrate_every</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration_ready</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">migration_num</span><span class="p">:</span>
                    <span class="c1"># This is the first island to reach this migration.</span>
                    <span class="c1"># Need to set global parameters for this migration.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">),</span>
                                                                             <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_to_migrate</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">migration_perms</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span><span class="p">)</span>
                                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_to_migrate</span><span class="p">)]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Island </span><span class="si">%i</span><span class="s1"> just set up the migration.&#39;</span> <span class="o">%</span> <span class="n">island</span><span class="p">)</span>

                <span class="c1"># Send the required PSets to migration_transit</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span><span class="p">[</span><span class="n">migration_num</span><span class="p">][</span><span class="n">island</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span>
                <span class="c1"># Tell other islands that this one is ready for this migration.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">migration_ready</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">=</span> <span class="n">migration_num</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration_ready</span><span class="p">):</span>
                <span class="c1"># This island performs a migration</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Island </span><span class="si">%i</span><span class="s1"> is migrating!&#39;</span> <span class="o">%</span> <span class="n">island</span><span class="p">)</span>
                <span class="n">migration_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Fetch the appropriate new individuals from migration_transit</span>
                <span class="k">for</span> <span class="n">migrater_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_to_migrate</span><span class="p">):</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span><span class="p">[</span><span class="n">migration_num</span><span class="p">][</span><span class="n">migrater_index</span><span class="p">]</span>  <span class="c1"># Index of the individual</span>
                    <span class="n">newisland</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_perms</span><span class="p">[</span><span class="n">migration_num</span><span class="p">][</span><span class="n">migrater_index</span><span class="p">][</span><span class="n">island</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span><span class="p">[</span><span class="n">migration_num</span><span class="p">][</span><span class="n">newisland</span><span class="p">][</span><span class="n">migrater_index</span><span class="p">]</span>

                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Island </span><span class="si">%i</span><span class="s1"> gained new individual with fitness </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">=</span> <span class="n">migration_num</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration_done</span><span class="p">)</span> <span class="o">==</span> <span class="n">migration_num</span><span class="p">:</span>
                    <span class="c1"># This is the last island to complete this migration</span>
                    <span class="c1"># Delete the migration data to free space.</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_transit</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_perms</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_indices</span><span class="p">[</span><span class="n">migration_num</span><span class="p">]</span>

            <span class="c1"># Set up the next generation</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">island</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;best&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
                    <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="n">best</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
                    <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="n">jj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">island</span><span class="p">])</span>
                <span class="c1"># If the new pset is a duplicate of one already in the island_map, it will cause problems.</span>
                <span class="c1"># As a workaround, perturb it slightly.</span>
                <span class="k">while</span> <span class="n">new_pset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span><span class="p">:</span>
                    <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_pset</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">island</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pset</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">island_map</span><span class="p">[</span><span class="n">new_pset</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">island</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_islands</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen</span><span class="si">%i</span><span class="s1">ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="n">jj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen</span><span class="si">%i</span><span class="s1">isl</span><span class="si">%i</span><span class="s1">ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">],</span> <span class="n">island</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">waiting_count</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_per_island</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Island </span><span class="si">%i</span><span class="s1"> completed </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_num</span><span class="p">[</span><span class="n">island</span><span class="p">]))</span>
                <span class="c1"># print(sorted(self.fitnesses[island]))</span>

            <span class="c1"># Convergence check</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_tolerance</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

            <span class="c1"># Return a copy, so our internal data structure is not tampered with.</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposed_individuals</span><span class="p">[</span><span class="n">island</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add no new jobs, wait for this generation to complete.</span>
            <span class="k">return</span> <span class="p">[]</span></div></div>


<div class="viewcode-block" id="AsynchronousDifferentialEvolution"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.AsynchronousDifferentialEvolution">[docs]</a><span class="k">class</span> <span class="nc">AsynchronousDifferentialEvolution</span><span class="p">(</span><span class="n">DifferentialEvolutionBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a simple asynchronous differential evolution algorithm.</span>

<span class="sd">    Contains no islands or migrations. Instead, each time a PSet finishes, proposes a new PSet at the same index using</span>
<span class="sd">    the standard DE formula and whatever the current population happens to be at the time.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AsynchronousDifferentialEvolution.__init__"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.AsynchronousDifferentialEvolution.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes algorithm based on the config object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AsynchronousDifferentialEvolution</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of individuals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of same shape, gives fitness of each individual</span></div>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AsynchronousDifferentialEvolution</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running Asyncrhonous Differential Evolution with population size </span><span class="si">%i</span><span class="s1"> for up to </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>

        <span class="c1"># Initialize random individuals</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;initialization&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lh&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">)]</span>

        <span class="c1"># Set all fitnesses to Inf, guaranteeing a replacement by the first proposed individual.</span>
        <span class="c1"># The first replacement will replace with a copy of the same PSet, with the correct objective calculated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen0ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>

<div class="viewcode-block" id="AsynchronousDifferentialEvolution.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.AsynchronousDifferentialEvolution.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when a simulation run finishes</span>

<span class="sd">        :param res: Result object</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">fitness</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=gen)\d+&#39;</span><span class="p">,</span> <span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=ind)\d+&#39;</span><span class="p">,</span> <span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fitness</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitness</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Do various &quot;per iteration&quot; stuff</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iters_complete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span>
            <span class="k">if</span> <span class="n">iters_complete</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">iters_complete</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> simulations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> simulations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size</span><span class="p">))</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current population fitnesses:&#39;</span><span class="p">)</span>
            <span class="n">print2</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">iters_complete</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> simulations&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims_completed</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iters_complete</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
            <span class="c1"># Convergence check</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_tolerance</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;best&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitnesses</span><span class="p">)</span>
            <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">:</span>
            <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_individual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gen</span><span class="si">%i</span><span class="s1">ind</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gen</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">new_pset</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="ScatterSearch"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ScatterSearch">[docs]</a><span class="k">class</span> <span class="nc">ScatterSearch</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements ScatterSearch as described in the introduction of Penas et al 2017 (but not the fancy parallelized</span>
<span class="sd">    version from that paper).</span>
<span class="sd">    Uses the individual combination method described in Egea et al 2009</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>  <span class="c1"># variables, popsize, maxiters, saveevery):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ScatterSearch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;reserve_size&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reserve_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;reserve_size&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reserve_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span>
        <span class="k">if</span> <span class="s1">&#39;init_size&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;init_size&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;init_size less than population_size. Setting it equal to population_size.&#39;</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s2">&quot;Scatter search parameter &#39;init_size&#39; cannot be less than &#39;population_size&#39;. &quot;</span>
                       <span class="s2">&quot;Automatically setting it equal to population_size.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;init_size less than population_size. Setting it equal to population_size.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_min_limit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;local_min_limit&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># {pendingPSet: parentPSet}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">received</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># {parentPSet: [(donependingPSet, score)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># (refPset, score)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># (Pset, score) pairs that were stuck for 5 gens, and so replaced.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ScatterSearch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">received</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running Scatter Search with population size </span><span class="si">%i</span><span class="s1"> (</span><span class="si">%i</span><span class="s1"> simulations per iteration) for </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
        <span class="c1"># Generate big number = 10 * variable_count (or user&#39;s chosen init_size) initial individuals.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;initialization&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lh&#39;</span><span class="p">:</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_size</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psets</span><span class="p">)):</span>
            <span class="n">psets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;init</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

        <span class="c1"># Generate a latin hypercube distributed &quot;reserve&quot;. When we need a random new individual, pop one from here</span>
        <span class="c1"># so we aren&#39;t repeating ground. Size of this could be customizable.</span>
        <span class="c1"># Note that this is not part of the original algorithm description, Eshan made it up</span>
        <span class="c1"># because otherwise, the &quot;choose a new random point&quot; step of the algorithm can cause useless repetition.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserve_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reserve_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">psets</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">received</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">return</span> <span class="n">psets</span>

    <span class="k">def</span> <span class="nf">round_1_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">start_psets</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">received</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Half is the top of the list, half is random.</span>
        <span class="n">topcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="n">randcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="n">start_psets</span><span class="p">[:</span><span class="n">topcount</span><span class="p">]</span>
        <span class="n">randindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">topcount</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_psets</span><span class="p">)),</span> <span class="n">randcount</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">randindices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_psets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">}</span>

<div class="viewcode-block" id="ScatterSearch.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ScatterSearch.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when a simulation run finishes</span>

<span class="sd">        :param res:</span>
<span class="sd">        :type res Result</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ps</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">ps</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">received</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ps</span><span class="p">,</span> <span class="n">score</span><span class="p">))</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">ps</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># All of this generation done, make the next list of psets</span>

            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">received</span><span class="p">:</span>
                <span class="c1"># This is the initialization round, special case</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">round_1_init</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1) Replace parent with highest scoring child</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">)):</span>
                    <span class="n">best_child</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">received</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">best_child</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="n">best_child</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_child</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_min_limit</span><span class="p">:</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="c1"># For output. Not the most efficient, but not in a performance-critical section</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">]</span> <span class="c1"># So this doesn&#39;t get huge</span>

                            <span class="c1"># Pick a new random pset</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reserve</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserve</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_pset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>  <span class="c1"># For simplicity, assume its score is awful</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stuckcounter</span><span class="p">[</span><span class="n">new_pset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># 2) Sort the refs list by quality.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Iteration </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current scores: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">]))</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Best archived scores: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_mins</span><span class="p">]))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

            <span class="c1"># 3) Do the combination antics to generate new candidates</span>
            <span class="n">query_psets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">):</span> <span class="c1"># parent index</span>
                <span class="k">for</span> <span class="n">hi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span><span class="p">):</span> <span class="c1"># helper index</span>
                    <span class="k">if</span> <span class="n">pi</span> <span class="o">==</span> <span class="n">hi</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                        <span class="c1"># d = (self.refs[hi][0][v] - self.refs[pi][0][v]) / 2.</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">hi</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">pi</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">pi</span><span class="p">)</span>
                        <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popsize</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="c1"># c1 = self.refs[pi][0][v] - d*(1 + alpha*beta)</span>
                        <span class="c1"># c2 = self.refs[pi][0][v] + d*(1 - alpha*beta)</span>
                        <span class="c1"># newval = np.random.uniform(c1, c2)</span>
                        <span class="c1"># newdict[v] = max(min(newval, var[2]), var[1])</span>
                        <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">pi</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">add_rand</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span> <span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)))</span>
                    <span class="n">newpset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
                    <span class="c1"># Check to avoid duplicate PSets. If duplicate, don&#39;t have to try again because SS doesn&#39;t really</span>
                    <span class="c1"># care about the number of PSets queried.</span>
                    <span class="k">if</span> <span class="n">newpset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">:</span>
                        <span class="n">newpset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">p</span><span class="si">%i</span><span class="s1">h</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
                        <span class="n">query_psets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newpset</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">newpset</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">pi</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">newpset</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">received</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">query_psets</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="ScatterSearch.get_backup_every"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.ScatterSearch.get_backup_every">[docs]</a>    <span class="k">def</span> <span class="nf">get_backup_every</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides base method because Scatter Search runs n*(n-1) PSets per iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;backup_every&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span> <span class="o">*</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;smoothing&#39;</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="BayesianAlgorithm"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">BayesianAlgorithm</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Superclass for Bayesian MCMC algorithms&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BayesianAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;step_size&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>  <span class="c1"># Iteration number that each PSet is on</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># List of n PSets corresponding to the n independent runs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># List of n probabilities of those n PSets.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;burn_in&#39;</span><span class="p">]</span>  <span class="c1"># todo: &#39;auto&#39; option</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;sample_every&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_hist_every</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_hist_every&#39;</span><span class="p">]</span>
        <span class="c1"># A list of the % credible intervals to save, eg [68. 95]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">credible_intervals</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;credible_intervals&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;hist_bins&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_priors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Results/samples.txt&#39;</span>

<div class="viewcode-block" id="BayesianAlgorithm.load_priors"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm.load_priors">[docs]</a>    <span class="k">def</span> <span class="nf">load_priors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds the data structures for the priors, based on the variables specified in the config.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Maps each variable to a 4-tuple (space, dist, val1, val2)</span>
        <span class="c1"># space is &#39;reg&#39; for regular space, &#39;log&#39; for log space. dist is &#39;n&#39; for normal, &#39;b&#39; for box.</span>
        <span class="c1"># For normal distribution, val1 = mean, val2 = sigma (in regular or log space as appropriate)</span>
        <span class="c1"># For box distribution, val1 = min, val2 = max (in regular or log space as appropriate)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;normal_var&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;reg&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;lognormal_var&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;uniform_var&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;reg&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;loguniform_var&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">p2</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setup_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;initialization&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;lh&#39;</span><span class="p">:</span>
            <span class="n">first_psets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_latin_hypercube_psets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_psets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_pset</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>  <span class="c1"># Forces accept on the first run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first_psets</span><span class="p">)):</span>
            <span class="n">first_psets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter0run</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

        <span class="c1"># Set up the output files</span>
        <span class="c1"># Cant do this in the constructor because that happens before the output folder is potentially overwritten.</span>
        <span class="k">if</span> <span class="n">setup_samples</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Name</span><span class="se">\t</span><span class="s1">Ln_probability</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">first_psets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys_to_string</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/Results/Histograms/&#39;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">first_psets</span>

    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;got_result() must be implemented in BayesianAlgorithm subclass&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BayesianAlgorithm.ln_prior"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm.ln_prior">[docs]</a>    <span class="k">def</span> <span class="nf">ln_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of the prior distribution for the given parameter set</span>

<span class="sd">        :param pset:</span>
<span class="sd">        :type pset: PSet</span>
<span class="sd">        :return: float value of ln times the prior distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">:</span>
            <span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pset</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">pset</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="c1"># Normal with mean x1 and value x2</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Uniform from x1 to x2</span>
                <span class="k">if</span> <span class="n">x1</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">x2</span><span class="p">:</span>
                    <span class="n">total</span> <span class="o">+=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Box-constrained parameter </span><span class="si">%s</span><span class="s1"> reached a value outside the box.&#39;</span><span class="p">)</span>
                    <span class="n">total</span> <span class="o">+=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">total</span></div>

<div class="viewcode-block" id="BayesianAlgorithm.sample_pset"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm.sample_pset">[docs]</a>    <span class="k">def</span> <span class="nf">sample_pset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pset</span><span class="p">,</span> <span class="n">ln_prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds this pset to the set of sampled psets for the final distribution.</span>
<span class="sd">        :param pset:</span>
<span class="sd">        :type pset: PSet</span>
<span class="sd">        :param ln_prob - The probability of this PSet to record in the samples file.</span>
<span class="sd">        :type ln_prob: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ln_prob</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">pset</span><span class="o">.</span><span class="n">values_to_string</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BayesianAlgorithm.update_histograms"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm.update_histograms">[docs]</a>    <span class="k">def</span> <span class="nf">update_histograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the files that contain histogram points for each variable</span>
<span class="sd">        :param file_ext: String to append to the save file names</span>
<span class="sd">        :type file_ext: str</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read the samples file into an array, ignoring the first row (header)</span>
        <span class="c1"># and first 2 columns (pset names, probabilities)</span>
        <span class="n">dat_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                  <span class="n">usecols</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Open the file(s) to save the credible intervals</span>
        <span class="n">cred_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">credible_intervals</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;/Results/credible</span><span class="si">%i%s</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">file_ext</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# param</span><span class="se">\t</span><span class="s1">lower_bound</span><span class="se">\t</span><span class="s1">upper_bound</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">cred_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_dir&#39;</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;/Results/Histograms/</span><span class="si">%s%s</span><span class="s1">.txt&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">file_ext</span><span class="p">)</span>
            <span class="c1"># For log-space variables, we want the histogram in log space</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
                <span class="n">histdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dat_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;log10_lower_bound</span><span class="se">\t</span><span class="s1">log10_upper_bound</span><span class="se">\t</span><span class="s1">count&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">histdata</span> <span class="o">=</span> <span class="n">dat_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;lower_bound</span><span class="se">\t</span><span class="s1">upper_bound</span><span class="se">\t</span><span class="s1">count&#39;</span>
            <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">histdata</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span>
            <span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">hist</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">result_array</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>

            <span class="n">sorted_data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dat_array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">interval</span><span class="p">,</span> <span class="n">file</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">credible_intervals</span><span class="p">,</span> <span class="n">cred_files</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_data</span><span class="p">)</span>
                <span class="n">want</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">interval</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">want</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">max_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">want</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">max_index</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">cred_files</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="BayesianAlgorithm.cleanup"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BayesianAlgorithm.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when quitting due to error.</span>
<span class="sd">        Save the histograms in addition to the usual algorithm cleanup&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_histograms</span><span class="p">(</span><span class="s1">&#39;_end&#39;</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">DreamAlgorithm</span><span class="p">(</span><span class="n">BayesianAlgorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **This algorithm is a work in progress, and does not currently work correctly. In our most recent testing, it</span>
<span class="sd">    generates incorrect probability distributions**</span>

<span class="sd">    Implements a variant of the DREAM algorithm as described in Vrugt (2016) Environmental Modelling</span>
<span class="sd">    and Software.</span>

<span class="sd">    Adapts Bayesian MCMC to use methods from differential evolution for accelerated convergence and</span>
<span class="sd">    more efficient sampling of parameter space</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DreamAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;You are running the DREAM algorithm. This is a work in progress, and is not officially supported! In &#39;</span>
               <span class="s1">&#39;our most recent testing, it generates incorrect probability distributions.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncr</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;crossover_number&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;crossover_number&#39;</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;gamma_prob&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rates</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>

    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the scheduler when a simulation is completed, with the pset that was run, and the resulting simulation</span>
<span class="sd">        data</span>

<span class="sd">        :param res: PSet that was run in this simulation</span>
<span class="sd">        :type res: Result</span>
<span class="sd">        :return: List of PSet(s) to be run next.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=run)\d+&#39;</span><span class="p">,</span> <span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Calculate posterior of finished job</span>
        <span class="n">lnprior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_prior</span><span class="p">(</span><span class="n">pset</span><span class="p">)</span>
        <span class="n">lnlikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="n">score</span>
        <span class="n">lnposterior</span> <span class="o">=</span> <span class="n">lnprior</span> <span class="o">+</span> <span class="n">lnlikelihood</span>

        <span class="c1"># Metropolis-Hastings criterion</span>
        <span class="n">ln_p_accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">lnposterior</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ln_p_accept</span><span class="p">:</span>  <span class="c1"># accept update based on MH criterion</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnposterior</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Record that this individual is complete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="c1"># Update histograms and trajectories if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_pset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_hist_every</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_histograms</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Wait for entire generation to finish</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>

            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Acceptance rates: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rates</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current -Ln Posteriors: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">))</span>

            <span class="n">next_gen</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">):</span>
                <span class="n">new_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_new_pset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_pset</span><span class="p">:</span>
                    <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">run</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">next_gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pset</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#  If new PSet is outside of variable bounds, keep current PSet and wait for next generation</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Proposed PSet </span><span class="si">%s</span><span class="s1"> is invalid.  Rejecting and waiting until next iteration&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">next_gen</span>

        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">calculate_new_pset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses differential evolution-like update to calculate new PSet</span>

<span class="sd">        :param idx: Index of PSet to update</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Choose individuals (not individual to be updated) for mutation</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_idcs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">all_idcs</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">sel</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># Sample the probability of modifying a parameter</span>
        <span class="n">cr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncr</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dim</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cr</span>  <span class="c1"># sample parameter subspace</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c1"># Sample whether to jump to the mode (when gamma = 1)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_prob</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span>

        <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">ds</span><span class="p">)):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;zeta&#39;</span><span class="p">])</span>
            <span class="n">lamb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">])</span>

            <span class="c1"># Differential evolution calculation (while satisfying detailed balance)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Do not reflect the parameter (need to reject if outside bounds)</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">zeta</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">lamb</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">diff</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">OutOfBoundsException</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is outside of bounds&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>


<div class="viewcode-block" id="BasicBayesMCMCAlgorithm"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">BasicBayesMCMCAlgorithm</span><span class="p">(</span><span class="n">BayesianAlgorithm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a Bayesian Markov chain Monte Carlo simulation.</span>

<span class="sd">    This is essentially a non-parallel algorithm, but here, we run n instances in parallel, and pool all results.</span>
<span class="sd">    This will give you a best fit (which is maybe not great), but more importantly, generates an extra result file</span>
<span class="sd">    that gives the probability distribution of each variable.</span>
<span class="sd">    This distribution depends on the prior, which is specified according to the variable initialization rules.</span>

<span class="sd">    With sa=True, this instead acts as a simulated annealing algorithm with n indepdendent chains.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">sa</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># expdata, objective, priorfile, gamma=0.1):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasicBayesMCMCAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sa</span> <span class="o">=</span> <span class="n">sa</span>

        <span class="k">if</span> <span class="n">sa</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cooling</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cooling&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_max</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;beta_max&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exchange_every</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;exchange_every&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_every</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reps_per_beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;reps_per_beta&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betas_per_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">reps_per_beta</span>  <span class="c1"># Number of unique betas considered (in PT)</span>

        <span class="c1"># The temperature of each replicate</span>
        <span class="c1"># For MCMC, probably n copies of the same number, unless the user set it up strangely</span>
        <span class="c1"># For SA, starts all the same (unless set up strangely), and independently decrease during the run</span>
        <span class="c1"># For PT, contains reps_per_beta copies of the same ascending sequence of betas, e.g.</span>
        <span class="c1"># [0.6, 0.8, 1., 0.6, 0.8, 1.]. Indices congruent to -1 mod (population_size/reps_per_beta) have the max beta</span>
        <span class="c1"># (probably 1), and only these replicas are sampled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betas</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;beta_list&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_priors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accepted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exchange_accepted</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">staged</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Used only when resuming a run and adding iterations</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasicBayesMCMCAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_file</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.start_run"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.start_run">[docs]</a>    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the scheduler at the start of a fitting run.</span>
<span class="sd">        Must return a list of PSets that the scheduler should run.</span>

<span class="sd">        :return: list of PSets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa</span><span class="p">:</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running simulated annealing on </span><span class="si">%i</span><span class="s1"> independent replicates in parallel, for </span><span class="si">%i</span><span class="s1"> iterations each or &#39;</span>
                   <span class="s1">&#39;until 1/T reaches </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_max</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running Markov Chain Monte Carlo on </span><span class="si">%i</span><span class="s1"> independent replicates in parallel, for </span><span class="si">%i</span><span class="s1"> iterations each.&#39;</span>
                       <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running parallel tempering on </span><span class="si">%i</span><span class="s1"> replicates for </span><span class="si">%i</span><span class="s1"> iterations, with replica exchanges performed &#39;</span>
                       <span class="s1">&#39;every </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_every</span><span class="p">))</span>

            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Statistical samples will be recorded every </span><span class="si">%i</span><span class="s1"> iterations, after an initial </span><span class="si">%i</span><span class="s1">-iteration burn-in period&#39;</span>
                   <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span><span class="p">))</span>

        <span class="n">setup_samples</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BasicBayesMCMCAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">start_run</span><span class="p">(</span><span class="n">setup_samples</span><span class="o">=</span><span class="n">setup_samples</span><span class="p">)</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.got_result"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.got_result">[docs]</a>    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the scheduler when a simulation is completed, with the pset that was run, and the resulting simulation</span>
<span class="sd">        data</span>

<span class="sd">        :param res: PSet that was run in this simulation</span>
<span class="sd">        :type res: Result</span>
<span class="sd">        :return: List of PSet(s) to be run next.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>

        <span class="c1"># Figure out which parallel run this is from based on the .name field.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=run)\d+&#39;</span><span class="p">,</span> <span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Calculate the acceptance probability</span>
        <span class="n">lnprior</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_prior</span><span class="p">(</span><span class="n">pset</span><span class="p">)</span> <span class="c1"># Need something clever for box constraints</span>
        <span class="n">lnlikelihood</span> <span class="o">=</span> <span class="o">-</span><span class="n">score</span>

        <span class="c1"># Because the P&#39;s are so small to start, we express posterior, p_accept, and current_P in ln space</span>
        <span class="n">lnposterior</span> <span class="o">=</span> <span class="n">lnprior</span> <span class="o">+</span> <span class="n">lnlikelihood</span>

        <span class="n">ln_p_accept</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">lnposterior</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Decide whether to accept move.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p_accept</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">]):</span>
            <span class="c1"># Accept the move, so update our current PSet and P</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accepted</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnposterior</span>
            <span class="c1"># For simulated annealing, reduce the temperature if this was an unfavorable move.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa</span> <span class="ow">and</span> <span class="n">ln_p_accept</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooling</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_max</span><span class="p">:</span>
                    <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Finished replicate </span><span class="si">%i</span><span class="s1"> because beta_max was reached.&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished replicate </span><span class="si">%i</span><span class="s1"> because beta_max was reached.&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_max</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;All annealing replicates have reached the maximum beta value&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Record the current PSet (clarification: what if failed? Sample old again?)</span>
        <span class="c1"># Using either the newly accepted PSet or the old PSet, propose the next PSet.</span>
        <span class="n">proposed_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_to_choose_new_pset</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">proposed_pset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">):</span>
                <span class="c1"># Do the replica exchange, then propose n new psets so all chains resume</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replica_exchange</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="n">print0</span><span class="p">(</span><span class="s1">&#39;Overall move accept rate: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accepted</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">attempts</span><span class="p">))</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

        <span class="n">proposed_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">run</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
        <span class="c1"># Note self.staged is empty unless we just resumed a run with added iterations and need to restart chains.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staged</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">toreturn</span> <span class="o">=</span> <span class="p">[</span><span class="n">proposed_pset</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">staged</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staged</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">toreturn</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">proposed_pset</span><span class="p">]</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.try_to_choose_new_pset"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.try_to_choose_new_pset">[docs]</a>    <span class="k">def</span> <span class="nf">try_to_choose_new_pset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function</span>
<span class="sd">        Advances the iteration number, and tries to choose a new parameter set for chain index i</span>
<span class="sd">        If that fails (e.g. due to a box constraint), keeps advancing iteration number and trying again.</span>

<span class="sd">        If it hits an iteration where it has to stop and wait (a replica exchange iteration or the end), returns None</span>
<span class="sd">        Otherwise returns the new PSet.</span>

<span class="sd">        :param index:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proposed_pset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># This part is a loop in case a box constraint makes a move automatically rejected.</span>
        <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">proposed_pset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loop_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">loop_count</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Instance </span><span class="si">%i</span><span class="s1"> spent 20 iterations at the same point&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;One of your samples is stuck at the same point for 20+ iterations because it keeps &#39;</span>
                       <span class="s1">&#39;hitting box constraints. Consider using looser box constraints or a smaller &#39;</span>
                       <span class="s1">&#39;step_size.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loop_count</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Instance </span><span class="si">%i</span><span class="s1"> terminated after 1000 iterations at the same point&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Instance </span><span class="si">%i</span><span class="s1"> was terminated after it spent 1000 iterations stuck at the same point &#39;</span>
                       <span class="s1">&#39;because it kept hitting box constraints. Consider using looser box constraints or a &#39;</span>
                       <span class="s1">&#39;smaller step_size.&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if it&#39;s time to do various things</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span> <span class="o">==</span> <span class="mi">0</span> \
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_sample</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_pset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">burn_in</span>
                   <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_hist_every</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_every</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                   <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_histograms</span><span class="p">(</span><span class="s1">&#39;_</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
                    <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current move accept rate: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accepted</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">attempts</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current replica exchange rate: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exchange_accepted</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed iteration </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Current move accept rate: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accepted</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">attempts</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Current replica exchange rate: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exchange_accepted</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sa</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Current betas: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">))</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current -Ln Likelihoods: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished replicate number </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Finished replicate number </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">exchange_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Need to wait for the rest of the chains to catch up to do replica exchange</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">proposed_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_new_pset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">proposed_pset</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.should_sample"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.should_sample">[docs]</a>    <span class="k">def</span> <span class="nf">should_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether this replica index is one that gets sampled.</span>
<span class="sd">        For mcmc, always True. For pt, must be a replica at the max beta</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">betas_per_group</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span> <span class="k">else</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.choose_new_pset"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.choose_new_pset">[docs]</a>    <span class="k">def</span> <span class="nf">choose_new_pset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldpset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to perturb the old PSet, generating a new proposed PSet</span>
<span class="sd">        If the new PSet fails automatically because it violates box constraints, returns None.</span>

<span class="sd">        :param oldpset: The PSet to be changed</span>
<span class="sd">        :type oldpset: PSet</span>
<span class="sd">        :return: the new PSet</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">delta_vector</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldpset</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">delta_vector_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">delta_vector</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
        <span class="n">delta_vector_normalized</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">*</span> <span class="n">delta_vector</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">delta_vector_magnitude</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldpset</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">oldpset</span><span class="p">:</span>
            <span class="c1"># For box constraints, need special treatment to keep correct statistics</span>
            <span class="c1"># If we tried to leave the box, the move automatically fails, we should increment the iteration counter</span>
            <span class="c1"># and retry.</span>
            <span class="c1"># The same could happen if normal_var&#39;s try to go below 0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">delta_vector_normalized</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
            <span class="k">except</span> <span class="n">OutOfBoundsException</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Rejected a move because </span><span class="si">%s</span><span class="s1">=</span><span class="si">%.2E</span><span class="s1"> moved by </span><span class="si">%f</span><span class="s1">, outside the box constraint [</span><span class="si">%.2E</span><span class="s1">, </span><span class="si">%.2E</span><span class="s1">]&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">oldpset</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">delta_vector_normalized</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.replica_exchange"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.replica_exchange">[docs]</a>    <span class="k">def</span> <span class="nf">replica_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs replica exchange for parallel tempering.</span>
<span class="sd">        Then proposes n new parameter sets to resume all chains after the exchange.</span>
<span class="sd">        :return: List of n PSets to run</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing replica exchange on iteration </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Who exchanges with whom is a little complicated. Each replica tries one exchange with a replica at the next</span>
        <span class="c1"># beta. But if we have multiple reps per beta, then the exchanges aren&#39;t necessarily within the same group of</span>
        <span class="c1"># reps. We use this random permutation to determine which groups exchange.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betas_per_group</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reps_per_beta</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reps_per_beta</span><span class="p">):</span>
                <span class="c1"># Determine the 2 indices we&#39;re exchanging, ind_hi and ind_lo</span>
                <span class="n">ind_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">betas_per_group</span> <span class="o">*</span> <span class="n">group</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">other_group</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
                <span class="n">ind_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">betas_per_group</span> <span class="o">*</span> <span class="n">other_group</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># Consider exchanging index ind_hi (higher T) with ind_lo (lower T)</span>
                <span class="n">ln_p_exchange</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">betas</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">]))</span>
                <span class="c1"># Scratch work: Should there be a - sign in front? You want to always accept if moving the better answer</span>
                <span class="c1"># to the lower temperature. ind_lo has lower T so higher beta, so the first term is positive. The second</span>
                <span class="c1"># term is positive if ind_lo is better. But you want a positive final answer when ind_hi, currently at</span>
                <span class="c1"># higher T, is better. So you need a - sign.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exchange_attempts</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ln_p_exchange</span><span class="p">):</span>
                    <span class="c1"># Do the exchange</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Exchanging individuals </span><span class="si">%i</span><span class="s1"> and </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ind_hi</span><span class="p">,</span> <span class="n">ind_lo</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exchange_accepted</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">hold_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">]</span>
                    <span class="n">hold_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_hi</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_pset</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span> <span class="o">=</span> <span class="n">hold_pset</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ln_current_P</span><span class="p">[</span><span class="n">ind_lo</span><span class="p">]</span> <span class="o">=</span> <span class="n">hold_p</span>
        <span class="c1"># Propose new psets - it&#39;s more complicated because of going out of box, and other counters.</span>
        <span class="n">proposed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">):</span>
            <span class="n">proposed_pset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_to_choose_new_pset</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">proposed_pset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_for_sync</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Aborting because no changes were made between one replica exchange and the next.&#39;</span><span class="p">)</span>
                    <span class="n">print0</span><span class="p">(</span><span class="s2">&quot;I seem to have gone from one replica exchange to the next replica exchange without &quot;</span>
                           <span class="s2">&quot;proposing a single valid move. Something is probably wrong for this to happen, so I&#39;m &quot;</span>
                           <span class="s2">&quot;going to stop.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
                <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Iteration number got off by 1 because try_to_choose_new_pset() was called twice: once a while ago</span>
                <span class="c1"># when it reached the exchange point and returned None, and a second time just now.</span>
                <span class="c1"># Need to correct for that here.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">proposed_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">run</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">proposed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proposed_pset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proposed</span></div>

<div class="viewcode-block" id="BasicBayesMCMCAlgorithm.cleanup"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.BasicBayesMCMCAlgorithm.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when quitting due to error.</span>
<span class="sd">        Save the histograms in addition to the usual algorithm cleanup&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_histograms</span><span class="p">(</span><span class="s1">&#39;_end&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">add_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">oldmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1"># Any chains that already completed need to be restarted with a new proposed parameter set</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_parallel</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">oldmax</span><span class="p">:</span>
                <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">try_to_choose_new_pset</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ps</span><span class="p">:</span>
                    <span class="c1"># Add to a list of new psets to run that will be submitted when the first result comes back.</span>
                    <span class="n">ps</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;iter</span><span class="si">%i</span><span class="s1">run</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Added PSet </span><span class="si">%s</span><span class="s1"> to BayesAlgorithm.staged to resume a chain&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">staged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimplexAlgorithm"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.SimplexAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">SimplexAlgorithm</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a parallelized version of the Simplex local search algorithm, as described in Lee and Wiswall 2007,</span>
<span class="sd">    Computational Economics</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimplexAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;simplex_start_point&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="c1"># We need to set up the initial point ourselfs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_start_point</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;simplex_max_iterations&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_max_iterations&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_start_point&#39;</span><span class="p">]</span>
        <span class="c1"># Set the start step for each variable to a variable-specific value, or else an algorithm-wide value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_steps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;logvar&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">p2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_steps</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">p2</span>
            <span class="k">elif</span> <span class="s1">&#39;simplex_log_step&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_steps</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_log_step&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_steps</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_step&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;population_size&#39;</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_reflection&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_expansion&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_contraction&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_shrink&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># (score, PSet) points making up the simplex. Sorted after each iteration.</span>

        <span class="c1"># Data structures to keep track of the progress of one iteration.</span>
        <span class="c1"># In these, index 0 corresponds to the process from the worst point on the simplex, simplex[-1], index 1 to</span>
        <span class="c1"># simplex[-2], etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Which stage of the iteration am I on? -1 initialization; 1 running first point; 2 running</span>
        <span class="c1"># second point; 3 done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store (score, PSet) after the first run of the iteration completes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store (score, PSet) after the second run completes, if applicable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Which case number triggered after I got the score for the first point? (1, 2 or 3)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Contains dicts containing the centroid of all simplex points except the one that I am</span>
        <span class="c1"># working with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Maps PSet name (str) to the index of the point in the above 3 lists.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refine</span> <span class="o">=</span> <span class="n">refine</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimplexAlgorithm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">bootstrap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_parse_start_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when the start point is not passed in the config (which is when we&#39;re doing a pure simplex run,</span>
<span class="sd">        as opposed to a refinement at the end of the run)</span>
<span class="sd">        Parses the info out of the variable specs, and sets the appropriate PSet into the config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
                <span class="n">start_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">p1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;logvar&#39;</span><span class="p">:</span>
                <span class="n">start_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">exp10</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">p1</span><span class="p">)))</span>
        <span class="n">start_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">start_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_start_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_pset</span>

    <span class="k">def</span> <span class="nf">start_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Running local optimization by the Simplex algorithm for </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">)</span>

        <span class="c1"># Generate the initial  num_variables+1 points in the simplex by moving parameters, one at a time, by the</span>
        <span class="c1"># specified step size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_init0&#39;</span>
        <span class="n">init_psets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_steps</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
            <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_init</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">new_pset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">init_psets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">init_psets</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init_psets</span>

    <span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>

        <span class="n">pset</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">pset</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">score</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pset</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Point is part of initialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">score</span><span class="p">,</span> <span class="n">pset</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Point is the 2nd point run within one iteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pset</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Point is the 1st point run within one iteration</span>
            <span class="c1"># We do the case-wise breakdown to pick the 2nd point, if any.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">pset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Case 1: The point is better than the current global min.</span>
                <span class="c1"># We calculate the expansion point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_plus_b_times_c_minus_d</span><span class="p">(</span><span class="n">pset</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">pset</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                                                                <span class="n">v</span><span class="p">))</span>
                    <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>
                <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
                <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_iter</span><span class="si">%i</span><span class="s1">_pt</span><span class="si">%i</span><span class="s1">-2&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">new_pset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">new_pset</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Case 2: The point is worse than the current min, but better than the next worst point</span>
                <span class="c1"># Note that simplex[-index-1] is the point that this one was built from, so we check [-index-2]</span>
                <span class="c1"># We don&#39;t run a second point in this case.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="c1"># Otherwise have to jump to next iteration, below.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Case 3: The point is not better than the next worst point.</span>
                <span class="c1"># We calculate the contraction point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="c1"># Work off the original or the reflection, whichever is better</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">a_hat</span> <span class="o">=</span> <span class="n">pset</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="o">-</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="c1"># I think the equation for this in Lee et al p. 178 is wrong; I am instead using the analog to the</span>
                    <span class="c1"># equation on p. 176</span>
                    <span class="c1"># new_dict[v] = self.centroids[index][v] + self.beta * (a_hat[v] - self.centroids[index][v])</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_plus_b_times_c_minus_d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">a_hat</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>
                <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
                <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_iter</span><span class="si">%i</span><span class="s1">_pt</span><span class="si">%i</span><span class="s1">-2&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">new_pset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">new_pset</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Internal error in SimplexAlgorithm&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># All points in current iteration completed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;output_every&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_results</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">print1</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Completed </span><span class="si">%i</span><span class="s1"> of </span><span class="si">%i</span><span class="s1"> iterations&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">))</span>
            <span class="n">print2</span><span class="p">(</span><span class="s1">&#39;Current best score: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If not an initialization iteration, update the simplex based on all the results</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">productive</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">)):</span>
                    <span class="n">si</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span>  <span class="c1"># Index into the simplex</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">productive</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">productive</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="n">productive</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="c1"># else don&#39;t edit the simplex, neither is an improvement</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Internal error in SimplexAlgorithm&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>  <span class="c1"># Quit after the final simplex update</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">productive</span><span class="p">:</span>
                    <span class="c1"># None of the points in the last iteration improved the simplex.</span>
                    <span class="c1"># Now we have to contract the simplex</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">new_simplex</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">)):</span>
                        <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                            <span class="c1"># new_dict[v] = self.tau * self.simplex[i-1][1][v] + (1 - self.tau) * self.simplex[i][1][v]</span>
                            <span class="n">new_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ab_plus_cd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
                            <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>
                        <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
                        <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_iter</span><span class="si">%i</span><span class="s1">_pt</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">new_pset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">new_simplex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pset</span><span class="p">)</span>

                    <span class="c1"># Prepare for new reinitialization run</span>
                    <span class="c1"># We don&#39;t need to rescore simplex[0], but the rest of the PSets are new and we do.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_simplex</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">return</span> <span class="n">new_simplex</span>

            <span class="c1">###</span>
            <span class="c1"># Set up the next iteration</span>
            <span class="c1"># Re-sort the simplex based on the updated objectives</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span> <span class="c1"># Extra catch if finish on a rebuild the simplex iteration</span>
            <span class="c1"># Find the reflection point for the n worst points</span>
            <span class="n">reflections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Sum of each param value, to help take the reflections</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sums</span><span class="p">()</span> <span class="c1"># Returns in log space for log variables</span>
            <span class="n">max_diff</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_count</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="o">-</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">new_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">this_centroid</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
                        <span class="c1"># Calc centroid in regular space.</span>
                        <span class="n">centroid</span> <span class="o">=</span> <span class="n">exp10</span><span class="p">((</span><span class="n">sums</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">sums</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">this_centroid</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">centroid</span>
                    <span class="c1"># new_dict[v] = centroid + self.alpha * (centroid - a[v])</span>
                    <span class="n">new_var</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_plus_b_times_c_minus_d</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">new_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>
                    <span class="n">max_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_diff</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_var</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">))))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_centroid</span><span class="p">)</span>
                <span class="n">new_pset</span> <span class="o">=</span> <span class="n">PSet</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
                <span class="n">new_pset</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;simplex_iter</span><span class="si">%i</span><span class="s1">_pt</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
                <span class="n">reflections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pset</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="p">[</span><span class="n">new_pset</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ai</span>
            <span class="c1"># Check for stop criterion due to moves being too small</span>
            <span class="k">if</span> <span class="n">max_diff</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;simplex_stop_tol&#39;</span><span class="p">]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Stopping simplex because the maximum move attempted this iteration was </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">max_diff</span><span class="p">)</span>
                <span class="k">return</span> <span class="s1">&#39;STOP&#39;</span>

            <span class="c1"># Reset data structures to track this iteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflections</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflections</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflections</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cases</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflections</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">reflections</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Wait for the rest of the parallel jobs to finish this iteration</span>
            <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="SimplexAlgorithm.get_sums"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.SimplexAlgorithm.get_sums">[docs]</a>    <span class="k">def</span> <span class="nf">get_sums</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplex helper function</span>
<span class="sd">        Returns a dict mapping parameter name p to the sum of the parameter value over the entire current simplex</span>
<span class="sd">        :return: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return {p: sum(point[1][p] for point in self.simplex) for p in self.simplex[0][1].keys()}</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
                <span class="n">sums</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sums</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sums</span></div>

<div class="viewcode-block" id="SimplexAlgorithm.a_plus_b_times_c_minus_d"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.SimplexAlgorithm.a_plus_b_times_c_minus_d">[docs]</a>    <span class="k">def</span> <span class="nf">a_plus_b_times_c_minus_d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the calculation a + b*(c-d), where a, c, and d are assumed to be in log space if v is in log space,</span>
<span class="sd">        and the final result respects the box constraints on v.</span>

<span class="sd">        :param a:</span>
<span class="sd">        :param b:</span>
<span class="sd">        :param c:</span>
<span class="sd">        :param d:</span>
<span class="sd">        :param v:</span>
<span class="sd">        :type v: FreeParameter</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span></div>

<div class="viewcode-block" id="SimplexAlgorithm.ab_plus_cd"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.SimplexAlgorithm.ab_plus_cd">[docs]</a>    <span class="k">def</span> <span class="nf">ab_plus_cd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the calculation ab + cd where b and d are assumed to be in log space if v is in log space,</span>
<span class="sd">        and the final result respects the box constraints on v</span>
<span class="sd">        :param a:</span>
<span class="sd">        :param b:</span>
<span class="sd">        :param c:</span>
<span class="sd">        :param d:</span>
<span class="sd">        :param v:</span>
<span class="sd">        :type v: FreeParameter</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">log_space</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="latin_hypercube"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.latin_hypercube">[docs]</a><span class="k">def</span> <span class="nf">latin_hypercube</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ndims</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Latin hypercube sampling.</span>

<span class="sd">    Returns a nsamples by ndims array, with entries in the range [0,1]</span>
<span class="sd">    You&#39;ll have to rescale them to your actual param ranges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Weird edge case - needed for other code counting on result having a number of rows</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">value_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="o">/</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)]</span>
                                         <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">)]))</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndims</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">value_table</span><span class="p">[:,</span> <span class="n">dim</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">value_table</span></div>


<div class="viewcode-block" id="exp10"><a class="viewcode-back" href="../../modules/algorithms.html#pybnf.algorithms.exp10">[docs]</a><span class="k">def</span> <span class="nf">exp10</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise 10 to the power of a possibly user-defined value, and raise a helpful error if it overflows</span>
<span class="sd">    :param n: A float</span>
<span class="sd">    :return: 10.** n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mf">10.</span><span class="o">**</span><span class="n">n</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">FloatingPointError</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Overflow error in exp10()&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_stack</span><span class="p">()))</span>  <span class="c1"># Log the entire traceback</span>
        <span class="k">raise</span> <span class="n">PybnfError</span><span class="p">(</span><span class="s1">&#39;Overflow when calculating 10^</span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Logs are saved in bnf.log</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;This may be because you declared a lognormal_var or a logvar, and specified the &#39;</span>
                         <span class="s1">&#39;arguments in regular space instead of log10 space.&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyBNF v0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Ryan Suderman, Eshan Mitra.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>